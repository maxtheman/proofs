[
  {
    "objectID": "assistant.html",
    "href": "assistant.html",
    "title": "Assistant",
    "section": "",
    "text": "Literally doesn’t work right now.\nThe main goal here is to find paths for converting between different types in Python. The approaches discussed in this answer implement the following techniques:\n\nExploring class hierarchy (subclass and superclass relationships) between types.\nUsing a unification-like approach to find common types and conversion paths between types.\n\nPython is quite different from Lean, a theorem prover that finds paths between types for the purpose of proving mathematical statements. Because of it’s dynamic and less strict type system, we are instead trying to create dictionaries to hold and identify conversion functions for different pairs of types.\nThere are probably better/different approaches, this is just a proof of concept.\n\nTriavial unification like-approach\nI think this is closer to lean? 1. Define a set of conversion functions between different types. 2. Create a dictionary that maps pairs of types to their corresponding conversion functions. 3. Implement a unification function that takes two types and returns their common type, if one exists. 4. Implement a function that finds a conversion path between two expressions by unifying their types and using the conversion functions. 5. Use the function to find conversion paths between expressions.\nThis could be interesting and offers a more perscriptive way to work with this., but would require a lot of work to make useful.\n\n# Step 1: Define conversion functions\ndef convert_int_to_float(x: int) -&gt; float:\n    return float(x)\n\ndef convert_float_to_str(x: float) -&gt; str:\n    return str(x)\n\n# Step 2: Create a dictionary of conversion functions\nconversion_dict = {\n    (int, float): convert_int_to_float,\n    (float, str): convert_float_to_str,\n}\n\n# Step 3: Implement a unification function\ndef unify_types(type1, type2):\n    if type1 == type2:\n        return type1\n\n    if (type1, type2) in conversion_dict:\n        return type2\n\n    if (type2, type1) in conversion_dict:\n        return type1\n\n    return None\n\n# Step 4: Implement a function to find conversion paths\ndef find_conversion_path(expr1, expr2):\n    type1 = type(expr1)\n    type2 = type(expr2)\n\n    common_type = unify_types(type1, type2)\n    print(common_type)\n\n    if common_type is None:\n        return None\n\n    path = []\n\n    if type1 != common_type:\n        path.append(conversion_dict[(type1, common_type)])\n\n    if type2 != common_type:\n        path.append(conversion_dict[(common_type, type2)])\n\n    return path\n\n\n# Step 5: Use the function to find conversion paths between expressions\nexpr1 = 1\nexpr2 = 2.0\nconversion_path = find_conversion_path(expr1, expr2)\n\n&lt;class 'float'&gt;\n\n\n\ntest_eq(conversion_path[0], convert_int_to_float)\n\nSo, lots of work for kind of a simple thing. TBD if it’s work revisiting in the future.\n\n\nExploring class hierarchy\n\nDefine a function to find the least common ancestor (LCA) of two types in the class hierarchy.\nImplement a function to find a conversion path between two expressions by finding their LCA and using the LCA to define a conversion function.\n\nI don’t think 2 is generally possible.\n\n# Step 1: Define a function to find the least common ancestor of two types\ndef least_common_ancestor(type1, type2):\n    type1_superclasses = inspect.getmro(type1)\n    type2_superclasses = inspect.getmro(type2)\n    print(type1_superclasses)\n    print(type2_superclasses)\n\n    if type1 in type2_superclasses:\n        return type1\n    if type2 in type1_superclasses:\n        return type2\n\n    for superclass1 in type1_superclasses:\n        if superclass1 in type2_superclasses:\n            return superclass1\n\n    return None\n\n# Step 2: Implement a function to find a conversion path between two expressions\ndef find_conversion_path(expr1, expr2):\n    type1 = type(expr1)\n    type2 = type(expr2)\n\n    common_ancestor = least_common_ancestor(type1, type2)\n\n    if common_ancestor is None:\n        # No common ancestor found in the class hierarchy\n        return None\n    \n    def conversion_function(x):\n        return common_ancestor(x)\n\n    return conversion_function\n\n\n# example heirarchy - D is a subclass of C, which is a subclass of A\nclass A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(C): pass\n\nexpr1 = B()\nexpr2 = D()\n\nconversion_function = find_conversion_path(expr1, expr2)\n\n(&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)\n(&lt;class '__main__.D'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)\n\n\n\nleast_common_ancestor(B, D)\n\n(&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)\n(&lt;class '__main__.D'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;)\n\n\n__main__.A\n\n\n\ntest_fail(lambda: conversion_function(expr1))\n\nThe above function does not run.\nI don’t know if this is generally possible, but the least common ancestor approach is promising. There may be some element of hardcoded vs least common ancestor that would be useful here."
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core",
    "section": "",
    "text": "source\n\n\n\n equation (name, variables, expression)\n\nCreates a function with the given name, variables, and expression.\n\nsource\n\n\n\n\n not_equals (lhs:Union[sympy.core.expr.Expr,sympy.core.basic.Basic],\n             rhs:Union[sympy.core.expr.Expr,sympy.core.basic.Basic])\n\n\nsource\n\n\n\n\n equals (lhs:sympy.core.expr.Expr, rhs:sympy.core.expr.Expr)\n\n\nsource\n\n\n\n\n constant (value:Union[int,float])\n\n\nsource\n\n\n\n\n variable (name:str)\n\n\nequation('f', [variable('x'), variable('y')], 1 - (1 - variable('x'))*(1- variable('y')))\n\n\\(\\displaystyle f{\\left(x,y \\right)} = - \\left(1 - x\\right) \\left(1 - y\\right) + 1\\)"
  },
  {
    "objectID": "core.html#helper-functions",
    "href": "core.html#helper-functions",
    "title": "Core",
    "section": "",
    "text": "source\n\n\n\n equation (name, variables, expression)\n\nCreates a function with the given name, variables, and expression.\n\nsource\n\n\n\n\n not_equals (lhs:Union[sympy.core.expr.Expr,sympy.core.basic.Basic],\n             rhs:Union[sympy.core.expr.Expr,sympy.core.basic.Basic])\n\n\nsource\n\n\n\n\n equals (lhs:sympy.core.expr.Expr, rhs:sympy.core.expr.Expr)\n\n\nsource\n\n\n\n\n constant (value:Union[int,float])\n\n\nsource\n\n\n\n\n variable (name:str)\n\n\nequation('f', [variable('x'), variable('y')], 1 - (1 - variable('x'))*(1- variable('y')))\n\n\\(\\displaystyle f{\\left(x,y \\right)} = - \\left(1 - x\\right) \\left(1 - y\\right) + 1\\)"
  },
  {
    "objectID": "core.html#core-functionality",
    "href": "core.html#core-functionality",
    "title": "Core",
    "section": "Core functionality",
    "text": "Core functionality\n\nsource\n\nmake_examples\n\n make_examples (domain:str, N:int, equation:str, positive_only:bool=False,\n                increasing_only:bool=False)\n\nFor a given domain and equation, select N examples and generate a list of N input-output pairs. Currently, the domain can only be ‘real’, and one variable is assumed.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndomain\nstr\n\nDomain of the example equation\n\n\nN\nint\n\nNumber of examples\n\n\nequation\nstr\n\nEquation to generate examples for\n\n\npositive_only\nbool\nFalse\nWhether to only generate positive inputs\n\n\nincreasing_only\nbool\nFalse\nWhether the domain should be increasing\n\n\nReturns\ntyping.List[typing.Tuple[sympy.core.expr.Expr, sympy.core.expr.Expr]]\n\nList of input-output pairs\n\n\n\n\nexamples = make_examples('real', 10, 'x**2')\nprint(examples)\n\n[(82, 6724), (-46, 2116), (-1, 1), (88, 7744), (-96, 9216), (27, 729), (24, 576), (-89, 7921), (75, 5625), (-33, 1089)]\n\n\n\nexamples = make_examples('real', 10, 'x**2', increasing_only=True)\nexamples\n\n[(94, 8836),\n (115, 13225),\n (147, 21609),\n (218, 47524),\n (224, 50176),\n (314, 98596),\n (354, 125316),\n (390, 152100),\n (398, 158404),\n (466, 217156)]\n\n\n\nmake_examples('real', 10, 'x**2', positive_only=True)\n\n[(85, 7225),\n (45, 2025),\n (73, 5329),\n (69, 4761),\n (89, 7921),\n (56, 3136),\n (7, 49),\n (28, 784),\n (74, 5476),\n (20, 400)]\n\n\n\nmake_examples('real', 10, 'x**2', positive_only=True, increasing_only=True)\n\n[(4, 16),\n (65, 4225),\n (97, 9409),\n (188, 35344),\n (278, 77284),\n (288, 82944),\n (341, 116281),\n (409, 167281),\n (503, 253009),\n (540, 291600)]\n\n\n\nassert len(examples) == 10\n\n\ntest_fail(lambda: make_examples('complex', 10, 'x**2'), contains=\"Domain complex not supported.\")\n\n\nsource\n\n\nprove\n\n prove (goal:Union[sympy.core.relational.Equality,sympy.core.relational.Un\n        equality,sympy.core.relational.Relational], proof_func:Callable[..\n        .,Union[sympy.core.relational.Equality,sympy.core.relational.Unequ\n        ality,sympy.core.relational.Relational]], *args)\n\nProve a goal using a proof function and arguments. The proof function should take the goal as the last argument and return the derived result. The goal is proved if the derived result matches the goal.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ngoal\ntyping.Union[sympy.core.relational.Equality, sympy.core.relational.Unequality, sympy.core.relational.Relational]\nGoal to prove\n\n\nproof_func\ntyping.Callable[…, typing.Union[sympy.core.relational.Equality, sympy.core.relational.Unequality, sympy.core.relational.Relational]]\nProof function\n\n\nargs\n\n\n\n\nReturns\nbool\nTrue if proof succeeds, False otherwise\n\n\n\n\ntest_eq(prove(equals(variable('x'), constant(2)), equals, variable('x'), constant(2)), True)\n\n\\[\\text \\quad x = 2 \\quad Q.E.D.\\]\n\n\n\nresult = prove(equals(variable('x'), constant(2)), equals, variable('x'), constant(3))\ntest_ne(result, True)\n\nProof failed: Derived result Eq(x, 3) does not match goal Eq(x, 2)\nCheck your assumptions and proof function for errors.\n\n\n\nsource\n\n\nprint_proof\n\n print_proof (proof:Callable[...,Union[sympy.core.relational.Equality,symp\n              y.core.relational.Unequality,sympy.core.relational.Relationa\n              l]], *args)\n\nPrint a proof step by step. Mostly used when defining a proof evaluation function. The proof function should take the goal as the last argument and return the derived result. The goal is proved if the derived result matches the goal. Comments do not support latex formatting, but the rest of the proof does.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nproof\ntyping.Callable[…, typing.Union[sympy.core.relational.Equality, sympy.core.relational.Unequality, sympy.core.relational.Relational]]\nthe proof function\n\n\nargs\n\n\n\n\nReturns\nNone\nno return value\n\n\n\n\ndef print_proof_example():\n    # This is a test function to show how print_proof works\n    x = variable('x')\n    # again\n    y = variable('y')\n    return equals(x, y)\n\nlatex = Latex(print_proof(print_proof_example))\n\n\\[\\mathtt{\\text{This is a test function to show how print\\_proof works}}\\]\n\n\n\\[x\\]\n\n\n\\[\\mathtt{\\text{again}}\\]\n\n\n\\[y\\]\n\n\n\nsource\n\n\ncontradiction_proof\n\n contradiction_proof (proof:Callable[...,Union[sympy.core.relational.Equal\n                      ity,sympy.core.relational.Unequality,sympy.core.rela\n                      tional.Relational]])\n\nWrap a proof function to prove a contradiction. The proof function should take the goal as the last argument and return the derived result. The goal is proved if the derived result matches the goal.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nproof\ntyping.Callable[…, typing.Union[sympy.core.relational.Equality, sympy.core.relational.Unequality, sympy.core.relational.Relational]]\nthe proof function\n\n\nReturns\ntyping.Callable[…, sympy.core.relational.Unequality]\nthe wrapped contradiction proof function to evaluate\n\n\n\n\nsource\n\n\ndirect_proof\n\n direct_proof (proof:Callable[...,Union[sympy.core.relational.Equality,sym\n               py.core.relational.Unequality,sympy.core.relational.Relatio\n               nal]])\n\nWrap a proof function to prove a direct proof. The proof function should take the goal as the last argument and return the derived result. The goal is proved if the derived result matches the goal.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nproof\ntyping.Callable[…, typing.Union[sympy.core.relational.Equality, sympy.core.relational.Unequality, sympy.core.relational.Relational]]\nthe proof function\n\n\nReturns\ntyping.Callable[…, sympy.core.relational.Equality]\nthe wrapped proof function to evaluate\n\n\n\nHere’s how to use a contradiction goal.\n\n# Start by defining your domain\narbitrary_x = variable(\"x\")\nexpression = arbitrary_x + 1\n\n# Then define your goal\ncontradiction_goal = not_equals(expression, arbitrary_x)\n\n@contradiction_proof\ndef proof_of_x_plus_one(x):\n    # Given x, Assume x + 1 = x is true for arbitrary_x\n    assumed_eq = equals(x + 1, x)\n\n    # Calculate x + 1\n    next = x + 1\n\n    # Observing x + 1 != x, we have reached a contradiction\n    return not_equals(next, assumed_eq.rhs)\n\n\nassert prove(contradiction_goal, proof_of_x_plus_one, arbitrary_x)\n# assert added for nbdev test\n\n\\[\\mathtt{\\text{Given x, Assume x + 1 = x is true for arbitrary\\_x}}\\]\n\n\n\\[x + 1 = x\\]\n\n\n\\[\\mathtt{\\text{Calculate x + 1}}\\]\n\n\n\\[x + 1\\]\n\n\n\\[\\mathtt{\\text{Observing x + 1 != x, we have reached a contradiction}}\\]\n\n\n\\[\\text \\quad x + 1 \\neq x \\quad Q.E.D.\\]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "proofs",
    "section": "",
    "text": "This is a proofs validator to help students and hobbyists do mathematical thinking and problem solving.\nIt’s for when you buy a math book from the local used book store, so you have a piece of software to use to explore the mathematical concepts alongside you that’s fun and easy to use for anybody with a programming background.\nIt’s supposed to validate what you’re doing in a “black box” kind of manner, and try to offer you guardrails enough that you can spot your mistakes and feel reasonably more confident you know what you’re doing.\nNot perfectly confident, reasonably."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "proofs",
    "section": "Install",
    "text": "Install\npip install proofs"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "proofs",
    "section": "How to use",
    "text": "How to use\nLet’s start with something simple, first, let’s prove that “Given x, Assume x + 1 = x is false for all x”\nThis should be obvious, which makes is great to show how to approach a proof.\n\nDefine the problem\nLook at examples\nDecide on a proof strategy\nWrite the proof\n\n\n# Start by defining your domain\narbitrary_x = variable(\"x\")\nexpression = arbitrary_x + 2\n\n\nprint(expression)\n\nx + 2\n\n\n\n# select a few examples from the reals\nmake_examples('real', 3, expression)\n\n[(-39, -37), (-13, -11), (7, 9)]\n\n\nHopefully these examples convice us that the statement is false. This suggests that we can prove it by contradiction.\n\n# Then define your goal\ncontradiction_goal = not_equals(expression, arbitrary_x)\n\n\n@contradiction_proof\ndef proof_of_x_plus_one(x):\n    # Given x, Assume x + 1 = x is true for arbitrary x\n    assumed_eq = equals(x + 1, x)\n\n    # Calculate x + 1\n    next = x + 1\n\n    # Observing x + 1 != x, we have reached a contradiction\n    return not_equals(next, assumed_eq.rhs)\n\n#Select an arbitrary x from the domain\nprove(contradiction_goal, proof_of_x_plus_one, arbitrary_x)\n\n\\[\\mathtt{\\text{Given x, Assume x + 1 = x is true for arbitrary x}}\\]\n\n\n\\[x + 1 = x\\]\n\n\n\\[\\mathtt{\\text{Calculate x + 1}}\\]\n\n\n\\[x + 1\\]\n\n\n\\[\\mathtt{\\text{Observing x + 1 != x, we have reached a contradiction}}\\]\n\n\nProof failed: Derived result Ne(x + 1, x) does not match goal Ne(x + 2, x)\nCheck your assumptions and proof function for errors.\n\n\nFalse\n\n\nWith this, we get:\n\nComplete latex rendering of the math we are doing in python and our logic\nvalidation that what we are returning from the proof matches the expected goal\nsome additional helpful errors"
  },
  {
    "objectID": "polynomials.html",
    "href": "polynomials.html",
    "title": "Polynomials",
    "section": "",
    "text": "A single variable polynomial with real coefficients is a function of the form \\(f\\) that takes a real number as input, produces a real number as output, and has the form:\n\\[f(x)=a_0+a_1x+a_2x^2+...+a_nx^n\\]\nwhere \\(a_0,a_1,...,a_n\\) are real numbers. The number \\(a_i\\) are called the coefficients of f. The degree of the polynomial is the integer \\(n\\).\n\nsource\n\nPolynomial\n\n Polynomial (function_name:str='f', variable_name:str='x',\n             degree:Union[int,str]='n', coefficient_name:str='a')\n\nA class used to represent a general polynomial, which is a function that both takes and returns real numbers. Currently only supports single-variable polynomial functions. Polynomials require: - coefficients - degree\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfunction_name\nstr\nf\nname of function\n\n\nvariable_name\nstr\nx\nname of variable\n\n\ndegree\ntyping.Union[int, str]\nn\ndegree of polynomial\n\n\ncoefficient_name\nstr\na\nstr for name of coefficients\n\n\n\n\nPolynomial().equality()\n\n\\(\\displaystyle f{\\left(x \\right)} = \\sum_{i=0}^{n} x^{i} {a}_{i}\\)\n\n\n\nprint(Polynomial())\n\nf(x) = a[0] * x**0 + a[1] * x**1 + ... + a[n] * x**n\n\n\n\ntest_eq(Polynomial().right_hand_side(), Polynomial().equality().rhs)\n\n\nx = variable('x')\nn = variable('n')\ni = variable('i')\na = sp.IndexedBase('a')\n\nf_x = sp.Sum(a[i] * x**i, (i, 0, n))\n\nf_x\n\ntest_eq(Polynomial().right_hand_side(), f_x)\n\n\nf_x\n\n\\(\\displaystyle \\sum_{i=0}^{n} x^{i} {a}_{i}\\)\n\n\n\n# create g(t) = 2 + 0t + 4t^2 - t^3\ng = Polynomial(variable_name='t', function_name='g', degree='n', coefficient_name='a')\n\n\ng.set_degree(3)\n\n\\(\\displaystyle g{\\left(t \\right)} = t^{3} {a}_{3} + t^{2} {a}_{2} + t {a}_{1} + {a}_{0}\\)\n\n\n\ng.set_coefficients([2, 0, 4, -1])\n\n\\(\\displaystyle g{\\left(t \\right)} = - t^{3} + 4 t^{2} + 2\\)\n\n\nIf you want to set a specific polynomial all at once, here’s a helper function for that:\n\nsource\n\n\npolynomial\n\n polynomial (degree:int, coefficients:list)\n\nReturns a polynomial function with the given degree and coefficients\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ndegree\nint\ndegree of polynomial\n\n\ncoefficients\nlist\nlist of coefficients starting with the lowest indexed coefficient\n\n\n\nSometimes it might be better to directly generate a polynomial with the equation function.\nFor example, to create the above polynomial as a one liner, see below. It’s up to you to decide which is clearer.\n\nequation('g', variable('t'), 2 + (0*variable('t')) + (4*variable('t')**2) + (-1*variable('t')**3))\n\n\\(\\displaystyle g{\\left(t \\right)} = - t^{3} + 4 t^{2} + 2\\)\n\n\n\n\nExistence and Uniqueness for Polynomials\nFor any integer \\(n\\geq 0\\), and any list of \\(n+1\\) points \\((x_0,y_0),(x_1,y_1),...,(x_n,y_n)\\) in R^2 there is a unique polynomial \\(f\\) of degree at most \\(n\\) such that \\(f(x_i)=y_i\\) for all \\(i=0,1,...,n\\).\n\npolynomial_to_test = polynomial(3, [2, 0, 4, -1])\nsimple_polynomial = polynomial(1, [1, 1])\n\npolynomial_to_test.polynomial\n\n\\(\\displaystyle f{\\left(x \\right)} = - x^{3} + 4 x^{2} + 2\\)\n\n\n\nsimple_polynomial.polynomial\n\n\\(\\displaystyle f{\\left(x \\right)} = x + 1\\)\n\n\n\nsample_pairs = make_examples('real', 6, 5, positive_only=True, increasing_only=True)\nfor pair in sample_pairs:\n    print(pair)\n    print('bigger:', polynomial_to_test.get_output(pair[0]))\n    print('simple:', simple_polynomial.get_output(pair[0]))\n\n(97, 5)\nbigger: Eq(f(97), -875035)\nsimple: Eq(f(97), 98)\n(187, 5)\nbigger: Eq(f(187), -6399325)\nsimple: Eq(f(187), 188)\n(261, 5)\nbigger: Eq(f(261), -17507095)\nsimple: Eq(f(261), 262)\n(315, 5)\nbigger: Eq(f(315), -30858973)\nsimple: Eq(f(315), 316)\n(338, 5)\nbigger: Eq(f(338), -38157494)\nsimple: Eq(f(338), 339)\n(382, 5)\nbigger: Eq(f(382), -55159270)\nsimple: Eq(f(382), 383)"
  }
]